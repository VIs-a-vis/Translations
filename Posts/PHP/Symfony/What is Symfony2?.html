<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <title>Что такое Symfony2?</title>
</head>
<body>
<div>
    <h1>Что такое Symfony2?</h1>
    <p>На прошлой неделе, я провел основную презентацию о Symfony2 на конференции Symfony <a href="http://symfonyday.com/">Day</a> в Кельне. Многие люди просили у меня слайды, но они были совсем пусты и не так полезны. Это пост более-менее о том, что я говорил в первой части выступления.</p>
    <h2>Что такое Symfony2?</h2>
    <p>Когда я спрашиваю людей, что для них Symfony2, большая часть говорит что-то вроде: Symfony2 полнофункциональный веб фреймворк, написанный на PHP. Некоторые также добавляют, что это MVC фреймворк. И некорые другие добавляют что это не связанный фреймворк. Это прекрасно и правильно. Но мое определение немного отличается. Позвольте рассказать вам что это такое и почему оно имеет значение.</p>
    <p>Symfony2 действительно о двух разных вещах.</p>
    <p>Первое, <em>Symfony2 набор многократно используемых, автономных, несвязанных и соединенных воедино PHP компонентов, которые решают общие проблемы веб разработки. </em></p>
    <p>Затем, основанный на этих компонентах, <em>Symfony2 также полнофункциональный веб фреймворк.</em></p>
    <p>В зависимости от вашего проекта и потребностей, вы можете либо выбрать некоторые Symfony2 компоненты и начать с ними свой проект или вы можете использовать полнофункциональный фреймворк и получить выгоду с плотной интеграции предоставляемой из коробки. И выбор между двумя различными подходами - это действительно для вас.</p>
    <h2>Является ли Symfony2 MVC фреймворком?</h2>
    <p>Если вы оглянетесь, то увидите, что наверное каждый фреймворк реализует паттерн MVC. И многие из них рекламируются, как MVC фреймворки... но не Symfony2. Посмотрите документацию и вы увидите, что паттерн MVC упоминается один или два раза, но Symfony2 никогда не определяется как MVC фреймворк. Почему?</p>
    <p>Потому что меня действительно не волнует, является ли Symfony2 MVC или нет. Вероятно, потому что слово MVC так перегружено и потому что, в любом случае, никто не реализует точно также паттерн MVC. Все что меня волнует, это <em>разделение проблем</em>. И если вам нравится называть Symfony2 MVC фреймворком, вы должны знать, что Symfony2 действительно предоставляет инструменты для части Controller, части View, но не части Model. Это позволяет вам самому создавать вашу модель или использовать другие инструменты, как ORM. Конечно, существует плотная интеграция с популярными ORM, такими как Doctrine2 или Propel; но они опциональны. В Symfony2 нет ключевых возможностей и никогда не будут полагаться на какую-либо ORM.</p>
    <p>Мне не нравится MVC, потому что это не то как работает веб. Symfony2 HTTP фреймворк; это Request/Response фреймворк. Это большая сделка. Фундаментальные принципы Symfony2 строятся вокруг спецификации HTTP.</p>
    <p>Мне не нравится MVC, потому что веб сильно развился за последние годы и некоторые проекты сильно различаются от проектов которые были несколько лет назад. Иногда, вам только нужен путь создания REST API. Иногда, логика в основном в браузере и сервер используется только для передачи данных (например backbone.js). И для этих проектов вам не нужен MVC фреймворк. Вам нужно что-нибудь для обработки запросов (Request) и возврата ответа (Response). Вам нужен фреймворк реализующий спецификацию HTTP. HTTP стриминг еще один пример того, что не вписывается в паттерн MVC.</p>
    <h3>Почему это имеет значение?</h3>
    <p>Мы должны лучше рекламировать Symfony2 как набор многократно используемых компонентов потому что я твердо верю, что рост сообщества в ближайшие годы в основном будет засчет принятия компонентов.</p>
    <p>И Symfony2 принимается, так, как мы продаем проект. Но это также зависит от восприятия проекта людьми. И т.к. Symfony 1.0 был в основном монолитным фреймворком, многие люди все еще думают, что Symfony действительно монолитный фреймворк. Надеюсь, что с выходом Symfony2 восприятие немного изменится, но это безусловно займет много времени.</p>
    <p>Это имеет значение, потому что, даже если каждый день будут создаваться новые фреймворки, я думаю, что в "enterprise", есть место только для 2 или может 3 PHP фреймворков. Вопрос таков: как мы будем побеждать в <strike>войне</strike> конкуренции фреймворков?</p>
    <p>Во-первых, мы должны внедрять постоянные инновации. Клювевым фактором является получение вдохновения из других технологий и языков, а также адаптация некоторых их концепций в PHP. Признаем, что эволяция веба тоже очень важна. И Symfony2 вероятно большой шаг вперед в этом направлении с многими великими инновациями, такими как, бандлы, HTTP-кеширование, дистрибутивы, dependency injection, te mplating engines, конфигурация посредством аннотаций, asset management, стабильное API, веб-профайлер и многое другое.</p>
    <p>Мы одержим победу в <strike>войне</strike> конкуренции фреймворков, если Symfony2 будет везде. И полнофунциональный фреймворк никогда не будет стандартом в мире PHP. Итак, мы должны пойти другим путем.</p>
    <p>Все состоит из обмена. Во-первых, не изобретать велосипеды и интегрировать по возможности как можно больше сторонних продуктов (например Monolog, Composer, Doctrine, Propel, Assetic, Twig, Swiftmailer и многих других); но в то же время мы хотим делиться нашей работой с другими; и вот, то время когда компоненты вступают в игру.</p>
    <p>Одна из целеей Symfony2 это предоставление строительных блоков для различных проектов. Но что я имею ввиду под проектами? Кто эти целевые пользователи Symfony2? Каждый: от личных проектов до коммерческих; и Open-Source. Личные проекты и Open-Source это новая цель.</p>
    <p>Silex вероятно отличный фреймворк для начинающих, малых и личных проектов иои даже малых коммерческих. Symfony2 отличный фреймворк для проектов побольше с десятками разработчиков и более сложной бизнес логикой. И компоненты Symfony2 для людей, которые не хотят использовать фреймворк, или для других Open-Source проектов, которые не хотят изобретать велосипед.</p>
    <p>В итоге, Symfony2 направлен на обеспечение низкоуровневой архитектуры PHP проектов.</p>
    <h3>Почему Symfony2?</h3>
    <p>Почему я думаю, что компоненты Symfony2 находятся в хорошем положении к становлению низкоуровневой архитектуры PHP-мира?</p>
    <p>Код это твердая скала. Основные компоненты Symfony2 являются результатом многолетней работы и вклада мноих разработчиков.</p>
    <p>Если вы взглянете на код, то заметите тег @api у некоторых классов и методов. Он обозначают стабильное публичное API. Этот тег обозначает, что метод (его имя, аргументы и возвращаемое значение) не будет изменяться в минорных версиях Symfony2. Если вы используете только стабильное API, ваш код не будет требовать обновлений, когда вы будете обновлять версию Symfony2. Это замечательная точка продаж (selling point).</p>
    <p>И последнее, но не по важности, мы пытаемся быть как можно безопаснее. Мы предоставляем многие фичи связанные с безопасностью в компонентах и иы также очень серьезно следим за безопасностью в коде. И благодаря нашему великолепному сообществу, мы смогли проввести аудит безопасности от профессиональной компании. Это то, что очевидно невозможно для малых проектов.</p>
    <p>Ниже несколько примеров ПО и библиотек, использующих в настоящее время компоненты Symfony2:</p>
    <ul>
        <li><em>Silex</em>: BrowserKit, CssSelector, DomCrawler, EventDispatcher, HttpFoundation, HttpKernel, Routing, Form, Translation, Validator</li>
        <li><em>Goutte</em>: BrowserKit, DomCrawler, CssSelector, Process, ClassLoader, Finder</li>
        <li><em>Behat</em>: Console, DependencyInjection, EventDispatcher, Finder, Yaml, Config, Translation</li>
        <li><em>Assetic</em>: Process</li>
        <li><em>Doctrine2</em>: Console, Yaml</li>
        <li><em>Propel2</em>: Console, ClassLoader, Yaml</li>
        <li><em>PHPUnit</em>: Yaml</li>
        <li><em>FLOW3</em>: Yaml</li>
        <li><em>Midguard CMS</em>: большинство из них будет в следующей версии?</li>
        <li><em>phpBB 4</em>: большинство из них?</li>
        <li>Drupal 8*: ClassLoader, HttpFoundation, HttpKernel?</li>
    </ul>
    <h3>Компоненты Symfony2</h3>
    <p>Давайте посмотрим, что эти компоненты могут сделать для вас. На сегодня мы имеем 21 компонент и любой из них может использоваться как отдельная библиотека:</p>
    <ul>
        <li>DependencyInjection</li>
        <li>EventDispatcher</li>
        <li>HttpFoundation</li>
        <li>DomCrawler</li>
        <li>ClassLoader</li>
        <li>CssSelector</li>
        <li>HttpKernel</li>
        <li>BrowserKit</li>
        <li>Templating</li>
        <li>Translation</li>
        <li>Serializer</li>
        <li>Validator</li>
        <li>Security</li>
        <li>Routing</li>
        <li>Console</li>
        <li>Process</li>
        <li>Config</li>
        <li>Finder</li>
        <li>Locale</li>
        <li>Yaml</li>
        <li>Form</li>
    </ul>
    <p>У каждого компонента есть свой <a href="https://github.com/symfony">Git</a> репозитарий. Вы можете получить код напрямую с него, или можете скачать архив, или установить из PEAR или даже установить с развивающегося установщика Composer (Composer это новый PHP установщик, работу над которым сообщество Symfony начало несколько месяцев назад и он будет активно использоваться в проектах Symfony для установки всех зависимостей).</p>
    <p>Во второй части этого поста, я попытаюсь продемонстрировать пощь некоторых компонентов с как можно наименьшим кодом.</p>
    <h4>ClassLoader</h4>
    <p>Компонент ClassLoader предоставляет автозагрузчик реализующий стандарт PSR-0 (который является стандартным способом загрузки классов с пространствами имен доступных в PHP 5.3). Также возможна загрузка классов, использующих конвенцию именования PEAR. Это очень гибко, и действительно для классов находящихся в разных директориях, основанных на вложенных пространствах имен. Вы даже можете создавать более, чем одной директории для одного пространства имен.</p>
    <pre><code>require_once __DIR__.'/src/Symfony/Component/ClassLoader/UniversalClassLoader.php';
 
use Symfony\Component\ClassLoader\UniversalClassLoader;
 
$loader = new UniversalClassLoader();
$loader->registerNamespaces(array(
    'Symfony'          => array(__DIR__.'/src', __DIR__.'/symfony/src'),
    'Doctrine\\Common' => __DIR__.'/vendor/doctrine-common/lib',
    'Doctrine\\DBAL'   => __DIR__.'/vendor/doctrine-dbal/lib',
    'Doctrine'         => __DIR__.'/vendor/doctrine/lib',
    'Monolog'          => __DIR__.'/vendor/monolog/src',
));
$loader->registerPrefixes(array(
    'Twig_' => __DIR__.'/vendor/twig/lib',
));
$loader->register();</code></pre>
    <p>Большую часть времени, Symfony2 ClassLoader это все, что вам нужно для автозагрузки всех ваших классов проекта. И для лучшей производительности, вы можете использовать версию универсального загрузчика классов с APC кешем.</p>
    <h4>Console</h4>
    <p>Даже если мы говорим о веб-фреймворке, приятно иметь некоторые инструменты для управления проектом из коммандной строки. В Symfony2 мы используем консоль для генерации CRUD, обновления схемы БД, и т.д. Это не обязательно, но очень удобно и может во много раз увеличить вашу производительность.</p>
    <p>Это пример показывает как можно очень легко создать инструмент коммандной строки:</p>
    <pre><code>use Symfony\Component\Console\Application;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
 
$console = new Application();
$console
    ->register('ls')
    ->setDefinition(array(
        new InputArgument('dir', InputArgument::REQUIRED, 'Directory name'),
    ))
    ->setDescription('Displays the files in the given directory')
    ->setCode(function (InputInterface $input, OutputInterface $output) {
        $dir = $input->getArgument('dir');
 
        $output->writeln(sprintf('Dir listing for <info>%s</info>', $dir));
    })
;
$console->run();</code></pre>
    <p>Всего лишь с 10 строчками кода вы получаете доступ к большому числу возможностей, таких как, подсветка вывода, абстракции для ввода и вывода (ак что вы легко можете протестировать ваши комманды unit-тестами), валидация, автоматические справочные сообщения и многое другое. Это реально мощный компонент.</p>
    <h4>YAML</h4>
    <p>YAML великолепный формат конфигурации. Это самый популярный компонент Symfony2 на данный момент, потому что это вероятно единственная библиотека на чистом PHP, реализующая большую часть спецификации YAML 1.2:</p>
    <pre><code>use Symfony\Component\Yaml\Yaml;
 
$array = Yaml::parse($file);
 
print Yaml::dump($array);</code></pre>
    <h4>Finder</h4>
    <p>Finder предоставляет очень удобный и приятный интерфейс для поиска файлов и директорий в файловой системе:</p>
    <pre><code>use Symfony\Component\Finder\Finder;
 
$finder = new Finder();
 
$iterator = $finder
  ->files()
  ->name('*.php')
  ->depth(0)
  ->size('>= 1K')
  ->in(__DIR__);
 
foreach ($iterator as $file) {
    print $file->getRealpath()."\n";
}</code></pre>
    <p>Но вы также можете использовать его для поиска файлов расположенных удаленно, как в этом примере мы ищем файлы на Amazon S3:</p>
    <pre><code>$s3 = new \Zend_Service_Amazon_S3($key, $secret);
$s3->registerStreamWrapper("s3");
 
$finder = new Finder();
$finder->name('photos*')->size('< 100K')->date('since 1 hour ago');
foreach ($finder->in('s3://bucket-name') as $file) {
    print $file->getFilename()."\n";
}</code></pre>
    <h4>Process</h4>
    <p>Компонент Process позволяет вам исполнять комманды в подпроцессе. В этом примере, я запускаю простой листинг директорий и получаю результат обратно:</p>
    <pre><code>use Symfony\Component\Process\Process;
 
$process = new Process('ls -lsa');
$process->setTimeout(3600);
$process->run();
if (!$process->isSuccessful()) {
    throw new RuntimeException($process->getErrorOutput());
}
 
print $process->getOutput();</code></pre>
    <p>Вы можете подумать, что этого легко добиться на чистом PHP, но это не особо так, если вы хотите позаботиться о тонких различиях между различными платформами.</p>
    <p>И если вы хотите иметь возможность получать ответ в реальном времени, просто передайте анонимную функцию методу run() и вы будете получать буффер вывода как только он станет доступным:</p>
    <pre><code>use Symfony\Component\Process\Process;
 
$process = new Process('ls -lsa');
$process->run(function ($type, $buffer) {
    if ('err' === $type) {
        echo 'ERR > '.$buffer;
    } else {
        echo 'OUT > '.$buffer;
    }
});</code></pre>
    <p>Это великолепно, если вы хотите исполнить долгую комманду (как синхнонизация файлов на удаленном сервере с помощью rsync) и получать ответ в реальном времени.</p>
    <h4>DomCrawler</h4>
    <p>Если вы знакомы с jQuery, DomCrawler его PHP эквивалент. Он позволяет вам перемещатьмя по DOM, или HTML, или XML документам:</p>
    <pre><code>use Symfony\Component\DomCrawler\Crawler;
 
$crawler = new Crawler();
$crawler->addContent('<html><body><p>Hello World!</p></body></html>');
 
print $crawler->filterXPath('descendant-or-self::body/p')->text();</code></pre>
</div>
<body>
</html>
